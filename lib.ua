# Experimental!
# Various math functions

# Extract real
R â†š â—ŒÂ°â„‚

# -- Averages --

# Arithmetic mean
Mean â† Ã·â§»âŸœ/+
# Geometric mean
GMean â† â¿ËœÃ·1â§»âŸœ/Ã—
# Harmonic mean
HMean â† Ã·/+âŸœâ§»ËœÃ·1
# Quadratic mean
QMean â† âˆšÃ·â§»âŸœ/+Ë™Ã—
# Median
# TODO: O(n) median algorithm?
Median â† Ã·2/+âŠâŠŸâŠƒâŒŠâŒˆÃ·2-1âŠ¸â§»â†

# Variance
Var â† -Ë™Ã—âˆ©Ã·âˆ©âŠƒâ§»/+âŸœË™Ã—
# Standard deviation
Stdev â† âˆšVar

# -- Matrices/Vectors --

# ? SwappedRows Pivot
GaussEliminateâ€¼ â†š âˆ§(
  âŠ¢â–âŠ¸âŒµâœâŠ™â†™Ã—0âŸœâŠ¡â¤šâŠ¸âŠ™â‰
  âœâŠâ‡Œ âŠƒâŠ™âŠ™âˆ˜^0 âŠŸâ¤™âŠ™âŠ™âˆ˜ âŠ™(âŠƒâ‹…âŠ™âˆ˜^1 â¤.â‰¥ÎµâŠ¸âŒµ) âŸœâŠ¡
  âŠ¸âœâŠ¡(Ã·âŠ¸âŠ¡:)âŠ¸:
  âœ(Â°âŠ‚â†»|ğ„âŒ-ËœâŠ¸âŠÃ—âŠ™(âŠ¡â¤šËœâŠ™â‰))âŠ¸:
)Â°âŠ

# Matrix Determinant
MDet â† â—Œâ£GaussEliminateâ€¼(â¥Â¯ğ„ğ„/â‰ )ğ„ğ„Ã— âŠ™0âŠ™1

# Perform Gauss-Jordan elimination
Mgje â† âŠââŠ—1âŠ¸â‰ 0 â¥(
  â†»â‚â£(âœâŠ™âŠ¢Ã·âŸœ(-âŠÃ—âŠ™âŠ¸âŠ¢âŠ‚0Ã·)Â°âŠ‚âŠ¸â‰¡âŠâŠ¢)â—ŒâŠš>1e-15âŒµâŠ¸âŠ¢
)âŠ¸â§»
# Mgje â† â£GaussEliminateâ€¼(|)(â¤"Elimination cannot be completed"0)

# Matrix Inverse
MInv â† |1 âŒ…(âœâ‰(â†˜Ã·2âŠ¸â§») â£Mgje(â¤"Matrix has no inverse"0) Ëœâ‰¡âŠ‚Ë™âŠ=Â°âŠ|MInv)

â”Œâ”€â•´test
  â¤â¤™â‰ 5 â…â‚ƒ MDet [1_Â¯3_Â¯1 1_Â¯1_Â¯2 1_0_0]
  â¤â¤™â‰ [0_0_1 Â¯0.4_0.2_0.2 0.2_Â¯0.6_0.4] â…â‚ƒ MInv [1_Â¯3_Â¯1 1_Â¯1_Â¯2 1_0_0]
  â¤â¤™â‰ Ë™âŠ=â‡¡3 â…â‚ƒ Mgje [1_Â¯3_Â¯1 1_Â¯1_Â¯2 1_0_0]

  Mgje [1_5_5
        4_5_Â¯10]
  â¤â¤™â‰ [1_0_Â¯5
       0_1_2]

  â…â‚‰ Mgje [3_Â¯1_10
           Â¯2_4_5
           1_1_8]
  â¤â¤™â‰ [1_0_4.5
       0_1_3.5
       0_0_0]

  â…â‚‰ Mgje [0_0_2_Â¯4_Â¯5
           0_1_Â¯1_1_3
           0_6_0_Â¯6_5]
  â¤â¤™â‰ [0_1_0_Â¯1_0
       0_0_1_Â¯2_0
       0_0_0_0_1]
â””â”€â•´

MSquarify â†š âœâ–³[.âˆšâŠ¢]
# Matrix Cofactors
MCof â† â¥Â¯âŠâ‰ .â—¿2Â°âŠMSquarifyâ‰¡(MDet MSquarifyâ‰¡âŠ¡âŠ™Â¤âŠšÂ¬âŠâ†¥Â°âŠŸ)âŠ™Â¤â¬š0â‰¡â‚€Â°âŠšâŠšâŠ¸=.

# Dot product
Dot â† /+Ã—
# Cross product
Cross â† â†»2-âˆ©(Ã—â†»2)â—¡:
# Matrix product
#
# Computes AB
# ? A B
Mmp â† |2 âŒ…(Ëœâœâ‰âŠDot|Mmp MInv)
# Matrix-vector product
#
# Computes MV where V is represented as a 1D list of numbers
# ? M V
Mvp â† |2 âŒ…(Dotâ‰|Mvp MInv)
# Matrix power
# ? P M
Mpow â† â—Œâ¥âŸœMmpâŠ™(:Ë™âŠ=Â°âŠ)
# TODO: Change to this if it comes to work with negative powers
# Mpow â† â¥âŸœMmpâŠ™(Ë™âŠ=Â°âŠ)

â”Œâ”€â•´test
  â¤â¤™â‰ [3_7 Â¯6_2] âŒMmp [1_0 0_1] [3_7 Â¯6_2]
  â¤â¤™â‰ [1_0 0_1] â… âŒMmp . [1_2 3_4]
  â¤â¤™â‰ 3 â… MDet [5_6 2_3]

  â¤â¤™â‰ [Â¯8 5 Â¯3 2 Â¯1 1 0 1 1 2 3 5 8] â‰¡(âŠ¢â™­Mpow) âœ-â‡¡Â¯7 6 Â¤ [1_1 1_0]
â””â”€â•´

QqpMask â†š [1_2_3_4
           2_Â¯1_4_Â¯3
           3_Â¯4_Â¯1_2
           4_3_Â¯2_Â¯1]
# Quaternion product
#
# Computes PQ for quaternion arrays P and Q.
#
# Semi-pervasive; the last axis of the inputs must be of length 4,
# and will be interpreted as the input quaternions' real, i, j, and k.
# ```uiua
# # Computes (1+2i+3j+4k)(1+3i+5j+7k) and (2+4i+6j+8k)(5+6i+7j+8k)
# Qqp [1_2_3_4 2_4_6_8] [1_3_5_7 5_6_7_8]
# ## â•­â”€
# ## â•·  Â¯48  6  6 12
# ##   Â¯120 24 60 48
# ##                 â•¯
# ```
# ? P Q
Qqp â† â‰âŠ•/+-1âŒµâŠ™Ã—âŸœÂ±QqpMaskâŠÃ—âˆ©Â°â‰
# Create 3D rotation quaternions.
#
# Expects an angle array Î¸ and a unit vector axis array U.
#
# Semi-pervasive; the unit vector array must have one extra trailing
# axis compared to the angle array, and that axis must be length 3.
#
# For each angle-vector pair, computes cos(Î¸/2) + Usin(Î¸/2).
# ```uiua
# # Creates two rotation quaternions:
# # - Î· radians about 0_0_1
# # - Ï€ radians about 3/5_4/5_0
# RQuat Î·_Ï€ [0_0_1 3/5_4/5_0]
# ```
# To use rotation quaternions created by `RQuat` to rotate 3D
# vectors, see `QRot`.
# ? Î¸ U
RQuat â† âœâŠ™Â°â‰âŠ‚ğ„âŒÃ—Â°âˆ Ã·2
# Quaternion rotation implementation
QRotImpl â†š âœâŠ™Â°â‰â†˜1 Qqp Qqp âŸœâœâˆ©Â°â‰(â¬š0â†™Â¯4:âœâ†˜Â¯ 1)
# Rotate a 3D vector array using a quaternion array.
#
# To create rotation quaternions to use with `QRot`, see `RQuat`.
#
# Expects a quaternion array Q and a 3D vector array V.
#
# Semi-pervasive; the input arrays should have matching shapes aside
# from the final axis, which should be of lengths 4 and 3 respectively.
#
# For each quaternion-vector pair, computes Q * V * Q'.
# ```uiua
# RQuat Î· 0_0_1        # Create a rotation by Î· radians about 0_0_1
# QRot Â¤:[3_2_0 1_3_2] # Use the quaternion to rotate 3_2_0 and 1_3_2
# ```
# `QRot` can be used with âœ to undo the rotations afterward.
# ? Q V
QRot â† âŒ…(QRotImpl|QRotImplâœ(â†˜1Â°â‰)Â¯)

â”Œâ”€â•´test
  â¤â¤™â‰ [Â¯48_6_6_12 Â¯120_24_60_48] Qqp [1_2_3_4 2_4_6_8] [1_3_5_7 5_6_7_8]
  â¤â¤™â‰ [Â¯2_3_0 Â¯3_1_2] â… QRot Â¤:[3_2_0 1_3_2] RQuat Î· 0_0_1
â””â”€â•´

# -- Number theory --

# Pervasive factorial
Fact â† /Ã—Â°â‰+1â¬š0â‰¡â‚€â‡¡

â”Œâ”€â•´test
  â¤â¤™â‰ [1 1 2 6 24 120 720 5040] Fact [0 1 2 3 4 5 6 7]
â””â”€â•´

# Gamma function
# Î“(z)
Gamma â† (
  -1/2 âŸœ(
    -1
    # From https://en.wikipedia.org/wiki/Lanczos_approximation
    Â°âŠ[
      0.9999999999999999
      1975.3739023578853
      Â¯4397.382392792243
      3462.6328459862716
      Â¯1156.9851431631168
      154.53815050252774
      Â¯6.253671612368916
      0.034642762454736804
      Â¯7.477617197444297e-7
      6.304125382185226e-8
      Â¯2.7405717035683877e-8
      4.048694881756761e-9
    ]
    /+Ã·âœâŠ¢â‹…1â‰¡+âŠ™Â¤âŠ™:
  )
  Ã—Ã—Ã— âˆšÏ„ â‚‘Â¯ â¤™â¿ â¤™+ 8 # g
)

â”Œâ”€â•´test
  â¤â¤™(<1eÂ¯10 âŒµ-) âˆšÏ€ Gamma 1/2
  â¤â¤™(<1eÂ¯10 âŒµ-) 24 Gamma 5
  â¤â¤™(<1eÂ¯10 âŒµ-) â„‚Â¯0.09161772311294437 0.024480267015440246 Gamma â„‚.Â¯âˆš2
â””â”€â•´

# Greatest common divisor
# 
# Ignores sign
GCD â† â—Œâ¢â¤šâ—¿Â±âŒµ
# Least common multiple
# 
# Ignores sign
LCM â† âŒµÃ·âŠƒGCDÃ—

â”Œâ”€â•´test
  â¤â¤™â‰ 6 GCD 18 24
  â¤â¤™â‰ 24 LCM 8 12
â””â”€â•´

# Encode an array of numbers into digits of a given base
# 
# Analogous to `â‹¯` for base 2; the least significant digit is first.
# 
# `Base` allows multiple bases as input.
# ```uiua
# # Encodes 6 in base 2, 7 in base 3, 8 in base 4, and 9 in base 5.
# Base [2_3 4_5] [6_7 8_9]
# ## â•­â”€
# ## â•· 0 1 1
# ## â•· 1 2 0
# ##
# ##   0 2 0
# ##   4 1 0
# ##         â•¯
# ```
# 
# You can use `âŒBase` to decode from a base/bases.
# ```uiua
# # Decodes 6 in base 2, 7 in base 3, 8 in base 4, and 9 in base 5.
# âŒBase [2_3 4_5] [[0_1_1 1_2_0] [0_2_0 4_1_0]]
# ## â•­â”€
# ## â•· 6 7
# ##   8 9
# ##       â•¯
# ```
Base â† âŒ…(
  â‰â—Œâˆ§âŠƒâ—¿(âŠ‚Â¤âŒŠÃ·)â¿âŠ™Â¤â‡Œâ‡¡/â†¥â™­+1âŒŠâŠƒâŒËœâ¿âŠ™âŠ™[]
| /+Ã—â¿âŠ™Â¤â‡¡â—¡â‹…â§»âŠ™Â°â‰)

â”Œâ”€â•´test
  â¤â¤™â‰ [[2_2 1_0][3_1 1_1]] Base 5 [12_1 8_6]
  â¤â¤™â‰ [[0_1_1 1_2_0][0_2_0 4_1_0]] Base [2_3 4_5] [6_7 8_9]
  â¤â¤™â‰ [12_1 8_6] âŒBase 5 [[2_2 1_0][3_1 1_1]]
  â¤â¤™â‰ [6_7 8_9] âŒBase [2_3 4_5] [[0_1_1 1_2_0][0_2_0 4_1_0]]
â””â”€â•´

# Inverse of N modulo M (M if nonexistent)
# ? N M
ModInv â† âŠ—1Ëœâ—¿Ã—â—¡â‹…â‡¡
# Multiplicative order of N modulo M
# ? N M
ModOrd â† âŠ¡1âŠš=1Ëœâ—¿â¿â—¡â‹…â‡¡

â”Œâ”€â•´test
  â¤â¤™â‰ 2 ModInv 4 7
â””â”€â•´

# Binomial coefficient aka N choose K
# ? K N
# Deprecated! Use `â§…<` instead.
Binom â† /Ã—Ã·+1âŸœ-â‡¡

# Convert a number X to a continued fraction to N terms.
# 
# Use `Â°CFrac` to convert to a number from a continued fraction.
# ? N X
CFrac â† âŒ…(â¥âŠƒ(Ã·â¤šâ—¿1)âŒŠ|âŠƒâ§»/(+ËœÃ·1)â‡Œ)

â”Œâ”€â•´test
  â¤â¤™â‰ [3 7 15 1 292 1 1 1] CFrac 8 Ï€
  â¤â¤™â‰ e â—ŒÂ°CFrac CFrac 100 e
â””â”€â•´

# Divisors of N (including 1 and N)
# The values are in increasing order and distinct.
# ? N
Divisors â† â—ŒÂ°â–½âŠ‚âŠƒÃ·â‡Œ â–½=0âŠ¸âŠƒâ—¿Ã· +1â‡¡âŒŠâŠ¸âˆš

â”Œâ”€â•´test
  â¤â¤™â‰ [1] Divisors 1
  â¤â¤™â‰ [1 2 3 4 6 9 12 18 36] Divisors 36
  â¤â¤™â‰ [1 2 4 5 8 10 20 25 40 50 100 125 200 250 500 1000] Divisors 1000
â””â”€â•´

# -- Probability --

# Error function
Erf â† (
  ËœÃ·1+1Ã—0.3275911 âŸœ(Ëœâ¿eÂ¯Ã—.) âŒµâŸœÂ±
  :[1.061405429 Â¯1.453152027 1.421413741
    Â¯0.284496736 0.254829592
  ]:0
  Ã—Â¬Ã—âˆ§(Ã—âŠ™+)Â¤
)

â”Œâ”€â•´test
  â¤â¤™â‰ 0 Erf 0
  â¤â¤™â‰ 1 Erf 1000
  â¤â¤™â‰ Â¯1 Erf Â¯1000
  â¤â¤™(<1e-6âŒµ-) 0.5204998778130465 Erf 0.5
  â¤â¤™(<1e-6âŒµ-) Â¯0.5204998778130465 Erf Â¯0.5
â””â”€â•´

# Seeded random indices from a distribution array
# 
# Given a seed, a shape, and a probability distribution array
# of any rank containing positive numbers, `DistRand` normalizes
# the distribution if necessary so it sums to 1, then returns
# an array of deep indices into the distribution arrays, chosen
# randomly weighted by the distribution. The generated random
# indices will fill the shape given to the function. If the
# distribution array is rank 1, the output will have the shape
# given. If the distribution array is rank >1, the output will
# have a shape equal to the shape given suffixed with the rank of
# the distribution array.
# 
# ```uiua
# # Generate random indices in the shape 2_3 with a seed of 8
# DistRand [0.1 0.4 0.3 0.2] 2_3 8
# ## â•­â”€
# ## â•· 1 2 3
# ##   2 1 2
# ##         â•¯
# ```
# Indices ? Distribution Shape Seed
DistRand â† Ëœâœâ™­â‰¡(âŠ¢âŠš>)âŠ“Â¤genâœâ™­\+Ã·/+âŠ¸â™­

# Box-Muller transform
# 
# Converts uniformly distributed pairs of input values to
# standard normally distributed pairs of output values
BoxMuller â† âˆ©Ã—â¤™âŠ“Â°âˆ âˆ˜Ã—Ï„:âˆšÃ—Â¯2Â°â‚‘Â¬

# Generate a 2 dimensional square Gaussian kernel
# ? Size StandardDeviation
Gaussian â† Ã·/+âŠ¸â™­â‚‘Â¯Ã·2Ë™Ã—ËœÃ·âŒµâŠâ„‚.-Ã·2-1âŸœâ‡¡

# Binomial distribution
# 
# Probability that n Bernoulli trials each with success probability p will amount to X successes
# ? p n X
BinomPmf â† Ã—Ã—âŠƒ(â‰¡â‚€â§…>|ğ„â¿|â¿âŠ“-Â¬) â¤šâ‹…:
# Cumulative binomial distribution
# 
# Probability that n Bernoulli trials each with success probability p will amount to X or fewer successes
# 
# **NOTE:** This function only accepts scalars for X. Use `each` or `rows` if multiple X values are desired
# ? p n X
BinomCmf â† /+BinomPmfâŠ“âˆ©Â¤(â‡¡+1)

# Geometric distribution
# 
# Probability of X failures before the first success of repeated trials with success probability p
# ? p X
GeomPmf â† Ã—Ëœâ¿Â¬âŸœ:
# Cumulative geometric distribution
# 
# Probability of X or fewer failures before the first success of repeated trials with success probability p
# ? p X
GeomCmf â† âœÂ¬Ëœâ¿âŠ™(+1)

# Poisson distribution
# 
# Probability of X occurrences of an unlikely event over many trials with expected value Î»
# ? Î» X
PoissonPmf â† Ã·âŠ™Ã—âŠƒ(â‹…Fact|Ëœâ¿|â‚‘Â¯)
# Cumulative Poisson distribution
# 
# Probability of X or fewer occurrences of an unlikely event over many trials with expected value Î»
# ? Î» X
PoissonCmf â† /+PoissonPmfâŠ“Â¤(â‡¡+1)

# Normal distribution
# 
# Probability density of a gaussian/bell curve with mean Î¼ and standard deviation Ïƒ
# ? Ïƒ Î¼ X
NormalPdf â† Ã·âŠƒ(Ã—âˆšÏ„|â‚‘Ã·2Â¯Ë™Ã—Ã·âŠ™-)
# Cumulative normal distribution
# 
# Probability that a normally distributed random variable with mean Î¼ and standard deviation Ïƒ is less than X
# ? Ïƒ Î¼ X
NormalCdf â† Ã·2+1ErfÃ·Ã—âˆš2âŠ™-

# -- Misc --

# Po-Shen quadratic solver
# 
# Returns roots as a list
# 
# Outputs complex-typed numbers only if the roots are complex
# ? A B C
Quad â† â¥RâŒµâ†¥â‚€:âŠŸâŠƒ-+âŠ™:âˆšâŸœÂ±Ëœ-Ë™Ã—âŸœ:â„‚â‚€Â¯Ã·â‚‚âˆ©âŒÃ·

â”Œâ”€â•´test
  â¤â¤™â‰ [1 2] Quad 1 Â¯3 2
  â¤â¤™â‰ [Â¯i i] Quad 1 0 1
  â¤â¤™â‰ âˆ©â† [â„‚3 Â¯1 â„‚Â¯1 2] â…â‚ƒ Quad 1 â„‚Â¯2 Â¯1 â„‚7 1
â””â”€â•´

# Powerset of a list
PSet â† âšâ–½â‹¯â‡¡Ëœâ¿2â§»âŸœÂ¤

# Rank-polymorphic fast fourier transform
# Deprecated! `fft` has been updated to be rank-polymorphic by default. Use that instead.
RPFFT â† âŒ…(â¥(â‰fft)â§»â–³.|â¥Â°(â‰fft)â§»â–³.)

# Rank-polymorphic convolution using fast fourier transform
â”Œâ”€â•´FFTConvolve
  # Full convolution wherever any overlap between the inputs exists
  Full â† â¥R=0â†¥âŠƒâˆ©type(Ã—âˆš/Ã—âŠ¸â–³âœâˆ©fftÃ—âˆ©âŒâ¬š0â†™-1+â—¡âˆ©â–³)
  Call â† Full
  # Convolution of only instances of complete overlap between inputs
  Valid â† â¥R=0â†¥âŠƒâˆ©type(â†˜-+1âŒµâŠ™âŸœ(Ã—âˆš/Ã—âŠ¸â–³âœâˆ©fftÃ—âˆ©âŒâ¬š0â†™)âŠƒ-â†¥â—¡âˆ©â–³)
  # Convolution that maintains the largest of the input dimensions
  Same â† â†™âŸœ(â†»âŒŠÃ·â‚‚-)âŠ™âŠ¸â–³â†¥âŠƒâˆ©â–³Full
â””â”€â•´
